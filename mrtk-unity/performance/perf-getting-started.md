---
title: Prise en main des performances
description: Documentation pour comprendre et ajuster la conformité dans MRTK.
author: keveleigh
ms.author: kurtie
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, développement, MRTK
ms.openlocfilehash: 1ddc057c7f3966375d512a5e4a714dce093412e6
ms.sourcegitcommit: c0ba7d7bb57bb5dda65ee9019229b68c2ee7c267
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/19/2021
ms.locfileid: "110144867"
---
# <a name="performance"></a><span data-ttu-id="01479-104">Performances</span><span class="sxs-lookup"><span data-stu-id="01479-104">Performance</span></span>

## <a name="getting-started"></a><span data-ttu-id="01479-105">Prise en main</span><span class="sxs-lookup"><span data-stu-id="01479-105">Getting started</span></span>

<span data-ttu-id="01479-106">Le moyen le plus simple de rationaliser les performances est d’utiliser la cadence ou le nombre de fois où votre application peut afficher une image par seconde.</span><span class="sxs-lookup"><span data-stu-id="01479-106">The easiest way to rationalize performance is via framerate or how many times your application can render an image per second.</span></span> <span data-ttu-id="01479-107">Il est important de se conformer à la fréquence d’images cible, comme indiqué par la plateforme ciblée (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="01479-107">It is important to meet the target framerate, as outlined by the platform being targeted (i.e</span></span> <span data-ttu-id="01479-108">[Windows Mixed Reality](/windows/mixed-reality/understanding-performance-for-mixed-reality), [Oculus](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/), etc.).</span><span class="sxs-lookup"><span data-stu-id="01479-108">[Windows Mixed Reality](/windows/mixed-reality/understanding-performance-for-mixed-reality), [Oculus](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/), etc).</span></span> <span data-ttu-id="01479-109">Par exemple, sur HoloLens, la fréquence d’images cible est de 60 FPS.</span><span class="sxs-lookup"><span data-stu-id="01479-109">For example, on HoloLens, the target framerate is 60 FPS.</span></span> <span data-ttu-id="01479-110">Les applications à fréquence faible peuvent entraîner des détériorations de l’expérience utilisateur, telles que la [stabilisation des hologrammes](../performance/hologram-stabilization.md), le suivi mondial, le suivi des mains et bien plus encore.</span><span class="sxs-lookup"><span data-stu-id="01479-110">Low framerate applications can result in deteriorated user experiences such as worsened [hologram stabilization](../performance/hologram-stabilization.md), world tracking, hand tracking, and more.</span></span> <span data-ttu-id="01479-111">Pour aider les développeurs à suivre et à obtenir une fréquence d’images de qualité, le kit de développement de la réalité mixte fournit un large éventail d’outils et de scripts.</span><span class="sxs-lookup"><span data-stu-id="01479-111">To help developers track and achieve quality framerate, the Mixed Reality Toolkit provides a variety of tools and scripts.</span></span>

### <a name="visual-profiler"></a><span data-ttu-id="01479-112">Générateur de profils Visual</span><span class="sxs-lookup"><span data-stu-id="01479-112">Visual profiler</span></span>

<span data-ttu-id="01479-113">Pour effectuer un suivi continu des performances pendant la durée de vie du développement, il est vivement recommandé de toujours afficher un visuel de fréquence lors de l’exécution & le débogage d’une application.</span><span class="sxs-lookup"><span data-stu-id="01479-113">To continuously track performance over the lifetime of development, it is highly recommended to always show a framerate visual while running & debugging an application.</span></span> <span data-ttu-id="01479-114">La boîte à outils de réalité mixte fournit l’outil de diagnostic du [profileur Visual](../features/diagnostics/using-visual-profiler.md) , qui fournit des informations en temps réel sur l’utilisation actuelle de la mémoire et fps dans la vue application.</span><span class="sxs-lookup"><span data-stu-id="01479-114">The Mixed Reality Toolkit provides the [Visual Profiler](../features/diagnostics/using-visual-profiler.md) diagnostic tool which gives real-time information about the current FPS and memory usage in application view.</span></span> <span data-ttu-id="01479-115">Le profileur Visual peut être configuré via les [paramètres système de diagnostics](../features/diagnostics/diagnostics-system-getting-started.md) dans l' [inspecteur de profils MRTK](../configuration/mixed-reality-configuration-guide.md).</span><span class="sxs-lookup"><span data-stu-id="01479-115">The Visual Profiler can be configured via the [Diagnostics System Settings](../features/diagnostics/diagnostics-system-getting-started.md) under the [MRTK Profiles Inspector](../configuration/mixed-reality-configuration-guide.md).</span></span>

<span data-ttu-id="01479-116">En outre, il est particulièrement important d’utiliser le générateur de profils Visual pour suivre les cadences lorsqu’elles s’exécutent sur l’appareil, par opposition à l’exécution dans l’éditeur Unity ou un émulateur.</span><span class="sxs-lookup"><span data-stu-id="01479-116">Furthermore, it is particularly important to utilize the Visual Profiler to track framerate when running on the device as opposed to running in Unity editor or an emulator.</span></span> <span data-ttu-id="01479-117">Les résultats de performances les plus précis seront représentés lors de l’exécution sur l’appareil avec des [Builds de configuration de version](/visualstudio/debugger/how-to-set-debug-and-release-configurations?preserve-view=true&view=vs-2019).</span><span class="sxs-lookup"><span data-stu-id="01479-117">The most accurate performance results will be depicted when running on the device with [Release configuration builds](/visualstudio/debugger/how-to-set-debug-and-release-configurations?preserve-view=true&view=vs-2019).</span></span>

> [!NOTE]
> <span data-ttu-id="01479-118">En cas de création pour Windows Mixed Reality, déployer avec les [Builds de configuration de Master](/windows/mixed-reality/exporting-and-building-a-unity-visual-studio-solution#building_and_deploying_a_unity_visual_studio_solution)</span><span class="sxs-lookup"><span data-stu-id="01479-118">If building for Windows Mixed Reality, deploy with [MASTER configuration builds](/windows/mixed-reality/exporting-and-building-a-unity-visual-studio-solution#building_and_deploying_a_unity_visual_studio_solution)</span></span>

![Interface du profileur Visual](../features/images/Diagnostics/VisualProfiler.png)

### <a name="optimize-window"></a><span data-ttu-id="01479-120">Fenêtre optimiser</span><span class="sxs-lookup"><span data-stu-id="01479-120">Optimize window</span></span>

<span data-ttu-id="01479-121">La [fenêtre MRTK Optimize](../features/tools/optimize-window.md) offre des outils d’informations et d’automatisation pour aider les développeurs de la réalité mixte à configurer leur environnement pour les meilleurs résultats et à identifier les goulots d’étranglement potentiels dans leur scène & ressources.</span><span class="sxs-lookup"><span data-stu-id="01479-121">The [MRTK Optimize Window](../features/tools/optimize-window.md) offers information and automation tools to help mixed reality developers set up their environment for the best performing results and identify potential bottlenecks in their scene & assets.</span></span> <span data-ttu-id="01479-122">Certaines configurations clés dans Unity peuvent aider à fournir des résultats sensiblement plus optimisés pour les projets de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="01479-122">Certain key configurations in Unity can help deliver substantially more optimized results for mixed reality projects.</span></span>

<span data-ttu-id="01479-123">En règle générale, ces paramètres impliquent des configurations de rendu idéales pour la réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="01479-123">Generally, these settings involve rendering configurations that are ideal for mixed reality.</span></span> <span data-ttu-id="01479-124">Les applications de réalité mixte sont uniques par rapport au développement graphique 3D traditionnel en ce qu’il y a deux écrans (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="01479-124">Mixed reality applications are unique compared to traditional 3D graphics development in that there are two screens (i.e</span></span> <span data-ttu-id="01479-125">deux yeux) à rendre pour l’ensemble de la scène.</span><span class="sxs-lookup"><span data-stu-id="01479-125">two eyes) to render for the entire scene.</span></span>

<span data-ttu-id="01479-126">Les paramètres recommandés référencés ci-dessous peuvent être configurés automatiquement dans un projet Unity en tirant parti de la fenêtre MRTK optimize.</span><span class="sxs-lookup"><span data-stu-id="01479-126">The recommended settings referenced below can be auto-configured in a Unity project by leveraging the MRTK Optimize Window.</span></span>

![Paramètres de la fenêtre d’optimisation MRTK](../features/images/performance/OptimizeWindow_Settings.png)

### <a name="unity-profiler"></a><span data-ttu-id="01479-128">Profileur Unity</span><span class="sxs-lookup"><span data-stu-id="01479-128">Unity Profiler</span></span>

<span data-ttu-id="01479-129">Le [profileur Unity](https://docs.unity3d.com/Manual/ProfilerWindow.html) est un outil utile pour examiner en détail les performances de l’application au niveau d’une image.</span><span class="sxs-lookup"><span data-stu-id="01479-129">The [Unity Profiler](https://docs.unity3d.com/Manual/ProfilerWindow.html) is a useful tool to investigate details of application performance at a frame-by-frame level.</span></span>

#### <a name="time-spent-on-the-cpu"></a><span data-ttu-id="01479-130">Temps passé sur le processeur</span><span class="sxs-lookup"><span data-stu-id="01479-130">Time spent on the CPU</span></span>

![Exemple de graphique du profileur Unity](../features/images/performance/UnityProfilerGraph.png)

<span data-ttu-id="01479-132">Pour conserver les fréquences d’images familières (généralement 60 images par seconde), les applications doivent atteindre une durée de trame maximale de 16,6 millisecondes du temps processeur.</span><span class="sxs-lookup"><span data-stu-id="01479-132">To maintain comfortable frame rates (typically 60 frames per second), applications need to achieve a maximum frame time of 16.6 milliseconds of CPU time.</span></span> <span data-ttu-id="01479-133">Pour vous aider à identifier le coût de la fonctionnalité MRTK, Microsoft Mixed Reality Toolkit contient des marqueurs pour les chemins de code de boucle interne (par trame).</span><span class="sxs-lookup"><span data-stu-id="01479-133">To help identify the cost of MRTK functionality, the Microsoft Mixed Reality Toolkit contains a markers for inner loop (per frame) code paths.</span></span> <span data-ttu-id="01479-134">Ces marqueurs utilisent le format suivant pour aider à comprendre la fonctionnalité spécifique utilisée :</span><span class="sxs-lookup"><span data-stu-id="01479-134">These markers use the following format, to assist in understanding the specific functionality being utilized:</span></span>

```
[MRTK] className.methodName
```

> [!Note]
> <span data-ttu-id="01479-135">Il peut y avoir des données supplémentaires à la suite du nom de la méthode.</span><span class="sxs-lookup"><span data-stu-id="01479-135">There may be additional data following the method name.</span></span> <span data-ttu-id="01479-136">Ce code est utilisé pour identifier les fonctionnalités exécutées de manière conditionnelle et potentiellement onéreuses qui peuvent être évitées par les petites modifications apportées au code de l’application.</span><span class="sxs-lookup"><span data-stu-id="01479-136">This is used to identify conditionally executed, potentially expensive functionality that may be avoided by small changes to application code.</span></span>

![Exemple de hiérarchie du profileur Unity](../features/images/performance/UnityProfilerHierarchy.png)

<span data-ttu-id="01479-138">Dans cet exemple, la hiérarchie a été développée pour montrer que la méthode UpdateHandData de la classe WindowsMixedRealityArticulatedHand utilise 0,44 ms du temps processeur pendant l’analyse du frame.</span><span class="sxs-lookup"><span data-stu-id="01479-138">In this example, the hierarchy has been expanded to show that the UpdateHandData method of WindowsMixedRealityArticulatedHand class is consuming 0.44 ms of CPU time during the frame being analyzed.</span></span> <span data-ttu-id="01479-139">Ces données peuvent être utilisées pour déterminer si un problème de performances est lié au code d’application ou à partir d’un autre emplacement du système.</span><span class="sxs-lookup"><span data-stu-id="01479-139">This data can be used to help determine if a performance issue is related to application code or from elsewhere in the system.</span></span>

<span data-ttu-id="01479-140">Il est vivement recommandé aux développeurs d’instrumenter le code de l’application de la même manière.</span><span class="sxs-lookup"><span data-stu-id="01479-140">It is highly recommended that developers instrument application code in a similar fashion.</span></span> <span data-ttu-id="01479-141">Les principaux domaines de focus pour l’instrumentation de code d’application se trouvent dans les gestionnaires d’événements, car ces méthodes sont facturées à la boucle de mise à jour MRTK à mesure que des événements sont déclenchés.</span><span class="sxs-lookup"><span data-stu-id="01479-141">Primary areas of focus for application code instrumentation is within event handlers as these methods are charged to the MRTK update loop as events are raised.</span></span> <span data-ttu-id="01479-142">Les temps de trames élevés dans la boucle de mise à jour MRTK peuvent indiquer un code coûteux dans les méthodes de gestionnaire d’événements.</span><span class="sxs-lookup"><span data-stu-id="01479-142">High frame times within the MRTK update loop can be indicative of expensive code in event handler methods.</span></span>

## <a name="recommended-settings-for-unity"></a><span data-ttu-id="01479-143">Paramètres recommandés pour Unity</span><span class="sxs-lookup"><span data-stu-id="01479-143">Recommended settings for Unity</span></span>

### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="01479-144">Rendu d’instance Single-Pass</span><span class="sxs-lookup"><span data-stu-id="01479-144">Single-Pass Instanced rendering</span></span>

<span data-ttu-id="01479-145">La configuration de rendu par défaut pour XR dans Unity est [Multi-Pass](https://docs.unity3d.com/ScriptReference/StereoRenderingPath.MultiPass.html).</span><span class="sxs-lookup"><span data-stu-id="01479-145">The default rendering configuration for XR in Unity is [Multi-pass](https://docs.unity3d.com/ScriptReference/StereoRenderingPath.MultiPass.html).</span></span> <span data-ttu-id="01479-146">Ce paramètre indique à Unity d’exécuter l’intégralité du pipeline de rendu deux fois, une fois pour chaque œil.</span><span class="sxs-lookup"><span data-stu-id="01479-146">This setting instructs Unity to execute the entire render pipeline twice, once for each eye.</span></span> <span data-ttu-id="01479-147">Cela peut être optimisé en sélectionnant [un rendu d’instance à passage unique](https://docs.unity3d.com/Manual/SinglePassInstancing.html) à la place.</span><span class="sxs-lookup"><span data-stu-id="01479-147">This can be optimized by selecting [Single Pass Instanced rendering](https://docs.unity3d.com/Manual/SinglePassInstancing.html) instead.</span></span> <span data-ttu-id="01479-148">Cette configuration s’appuie sur les [tableaux cibles de rendu](https://en.wikipedia.org/wiki/Multiple_Render_Targets) pour pouvoir effectuer un appel de dessin unique dans la cible de [rendu](https://en.wikipedia.org/wiki/Render_Target) appropriée pour chaque œil.</span><span class="sxs-lookup"><span data-stu-id="01479-148">This configuration leverages [render target arrays](https://en.wikipedia.org/wiki/Multiple_Render_Targets) to be able to perform a single draw call that instances into the appropriate [render target](https://en.wikipedia.org/wiki/Render_Target) for each eye.</span></span> <span data-ttu-id="01479-149">En outre, ce mode permet d’effectuer tout le rendu dans une seule exécution du pipeline de rendu.</span><span class="sxs-lookup"><span data-stu-id="01479-149">Furthermore, this mode allows all rendering to be done in a single execution of the rendering pipeline.</span></span> <span data-ttu-id="01479-150">Par conséquent, la sélection d’un rendu d’instance à passage unique comme chemin de rendu pour une application de réalité mixte peut [gagner beaucoup de temps sur le processeur & GPU](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/) et est la configuration de rendu recommandée.</span><span class="sxs-lookup"><span data-stu-id="01479-150">Thus, selecting Single Pass Instanced rendering as the rendering path for a mixed reality application can [save substantial time on both the CPU & GPU](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/) and is the recommended rendering configuration.</span></span>

<span data-ttu-id="01479-151">Toutefois, pour pouvoir émettre un appel de dessin unique pour chaque maille à chaque œil, l' [instanciation du GPU](https://docs.unity3d.com/Manual/GPUInstancing.html) doit être prise en charge par tous les nuanceurs.</span><span class="sxs-lookup"><span data-stu-id="01479-151">However, in order to issue a single draw call for each mesh to each eye, [GPU instancing](https://docs.unity3d.com/Manual/GPUInstancing.html) must be supported by all shaders.</span></span> <span data-ttu-id="01479-152">L’instanciation permet au GPU de multiplexer les appels de dessin sur les deux yeux.</span><span class="sxs-lookup"><span data-stu-id="01479-152">Instancing allows the GPU to multiplex draw calls across both eyes.</span></span> <span data-ttu-id="01479-153">Les nuanceurs intégrés Unity ainsi que le [nuanceur standard MRTK](../features/rendering/mrtk-standard-shader.md) contiennent par défaut les instructions d’instanciation nécessaires dans le code du nuanceur.</span><span class="sxs-lookup"><span data-stu-id="01479-153">Unity built-in shaders as well as the [MRTK Standard shader](../features/rendering/mrtk-standard-shader.md) by default contain the necessary instancing instructions in shader code.</span></span> <span data-ttu-id="01479-154">Si vous écrivez des nuanceurs personnalisés pour Unity, ces nuanceurs devront peut-être être mis à jour pour prendre en charge le rendu d’instance à passage unique.</span><span class="sxs-lookup"><span data-stu-id="01479-154">If writing custom shaders though for Unity, these shaders may need to be updated to support Single Pass Instanced rendering.</span></span>

#### <a name="example-code-for-custom-shader"></a>[<span data-ttu-id="01479-155">Exemple de code pour un nuanceur personnalisé</span><span class="sxs-lookup"><span data-stu-id="01479-155">Example Code for Custom Shader</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html)

```
struct appdata
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;

    UNITY_VERTEX_INPUT_INSTANCE_ID //Insert
};

struct v2f
{
    float2 uv : TEXCOORD0;
    float4 vertex : SV_POSITION;

    UNITY_VERTEX_OUTPUT_STEREO //Insert
};

v2f vert (appdata v)
{
    v2f o;

    UNITY_SETUP_INSTANCE_ID(v); //Insert
    UNITY_INITIALIZE_OUTPUT(v2f, o); //Insert
    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); //Insert

    o.vertex = UnityObjectToClipPos(v.vertex);

    o.uv = v.uv;

    return o;
}
```

### <a name="quality-settings"></a><span data-ttu-id="01479-156">Paramètres de qualité</span><span class="sxs-lookup"><span data-stu-id="01479-156">Quality settings</span></span>

<span data-ttu-id="01479-157">Unity fournit des [présélections pour contrôler la qualité](https://docs.unity3d.com/Manual/class-QualitySettings.html) du rendu pour chaque point de terminaison de plateforme.</span><span class="sxs-lookup"><span data-stu-id="01479-157">Unity provides [presets to control quality](https://docs.unity3d.com/Manual/class-QualitySettings.html) of rendering for each platform endpoint.</span></span> <span data-ttu-id="01479-158">Ces paramètres prédéfinis contrôlent les fonctionnalités graphiques qui peuvent être activées, telles que les ombres, l’anticrénelage, l’éclairage global et bien plus encore.</span><span class="sxs-lookup"><span data-stu-id="01479-158">These presets control what graphical features can be enabled such as shadows, anti-aliasing, global illumination, and more.</span></span> <span data-ttu-id="01479-159">Il est recommandé de réduire ces paramètres et d’optimiser le nombre de calculs effectués lors du rendu.</span><span class="sxs-lookup"><span data-stu-id="01479-159">It is recommended to lower these settings and optimize the number of calculations performed during rendering.</span></span>

<span data-ttu-id="01479-160">*Étape 1 :* Mettre à jour les projets Unity de réalité mixte pour utiliser le paramètre de niveau de *qualité faible*</span><span class="sxs-lookup"><span data-stu-id="01479-160">*Step 1:* Update mixed reality Unity projects to use the *Low Quality* level setting</span></span>  
<span data-ttu-id="01479-161">**Modifier**  >  **Paramètres du projet**, puis sélectionnez la catégorie **qualité** > sélectionnez *faible qualité* pour la plateforme UWP.</span><span class="sxs-lookup"><span data-stu-id="01479-161">**Edit** > **Project Settings**, then select the **Quality** category >  Select *Low Quality* for the UWP Platform</span></span>

<span data-ttu-id="01479-162">*Étape 2 :* Pour chaque fichier de scène Unity, désactiver l' [éclairage global en temps réel](https://docs.unity3d.com/Manual/LightMode-Realtime.html)</span><span class="sxs-lookup"><span data-stu-id="01479-162">*Step 2:* For every Unity scene file, disable [real-time Global Illumination](https://docs.unity3d.com/Manual/LightMode-Realtime.html)</span></span>  
<span data-ttu-id="01479-163">**Fenêtre**  >  **Rendu**  >  **Paramètres**  >  d’éclairage [Décocher l' *éclairage global en temps réel*](https://docs.unity3d.com/Manual/GlobalIllumination.html)</span><span class="sxs-lookup"><span data-stu-id="01479-163">**Window** > **Rendering** > **Lighting Settings** > [Uncheck *Real-time Global Illumination*](https://docs.unity3d.com/Manual/GlobalIllumination.html)</span></span>

### <a name="depth-buffer-sharing-hololens"></a><span data-ttu-id="01479-164">Partage de mémoire tampon de profondeur (HoloLens)</span><span class="sxs-lookup"><span data-stu-id="01479-164">Depth buffer sharing (HoloLens)</span></span>

<span data-ttu-id="01479-165">En cas de développement pour la plateforme Windows Mixed Reality et en particulier HoloLens, l’activation du *partage de mémoire tampon de profondeur* sous les *paramètres XR* peut aider à la [stabilisation des hologrammes](../performance/hologram-stabilization.md).</span><span class="sxs-lookup"><span data-stu-id="01479-165">If developing for the Windows Mixed Reality platform and in particular HoloLens, enabling *Depth Buffer Sharing* under *XR Settings* can help with [hologram stabilization](../performance/hologram-stabilization.md).</span></span> <span data-ttu-id="01479-166">Toutefois, le traitement du tampon de profondeur peut entraîner des coûts de performances, en particulier si vous utilisez un [format de profondeur 24 bits](https://docs.unity3d.com/ScriptReference/PlayerSettings.VRWindowsMixedReality-depthBufferFormat.html).</span><span class="sxs-lookup"><span data-stu-id="01479-166">However, processing of the depth buffer can incur a performance cost, particularly if using [24-bit depth format](https://docs.unity3d.com/ScriptReference/PlayerSettings.VRWindowsMixedReality-depthBufferFormat.html).</span></span> <span data-ttu-id="01479-167">Par conséquent, il est *fortement recommandé* de configurer le tampon de profondeur sur une précision de 16 bits.</span><span class="sxs-lookup"><span data-stu-id="01479-167">Thus, it is *highly recommended* to configure the depth buffer to 16-bit precision.</span></span>

<span data-ttu-id="01479-168">Si la [superposition](https://en.wikipedia.org/wiki/Z-fighting) se produit en raison du format binaire inférieur, vérifiez que le [plan de découpage](https://docs.unity3d.com/Manual/class-Camera.html) de l’ensemble des caméras est défini sur la valeur la plus basse possible pour l’application.</span><span class="sxs-lookup"><span data-stu-id="01479-168">If [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) occurs due to the lower bit format, confirm the [far clip plane](https://docs.unity3d.com/Manual/class-Camera.html) of all cameras is set to the lowest possible value for the application.</span></span> <span data-ttu-id="01479-169">Unity par défaut définit un plan de découpage Far de 1000MD.</span><span class="sxs-lookup"><span data-stu-id="01479-169">Unity by default sets a far clip plane of 1000m.</span></span> <span data-ttu-id="01479-170">Sur HoloLens, un plan de découpage lointain de 50 millions est généralement plus que suffisant pour la plupart des scénarios d’application.</span><span class="sxs-lookup"><span data-stu-id="01479-170">On HoloLens, a far clip plane of 50m is generally more than enough for most application scenarios.</span></span>

> [!NOTE]
> <span data-ttu-id="01479-171">Si vous utilisez le *format de profondeur 16 bits, les* effets requis pour la mémoire tampon des stencils ne fonctionneront pas, car [Unity ne crée pas de tampon de stencil](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html) dans ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="01479-171">If using *16-bit depth format*, stencil buffer required effects will not work because [Unity does not create a stencil buffer](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html) in this setting.</span></span> <span data-ttu-id="01479-172">Si vous sélectionnez le *format de profondeur 24 bits* , vous créez généralement une mémoire tampon de stencil de 8 bits, le cas échéant sur la plateforme graphique de point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="01479-172">Selecting *24-bit depth format* conversely will generally create an 8-bit stencil buffer, if applicable on the endpoint graphics platform.</span></span>
>
> <span data-ttu-id="01479-173">Si vous utilisez un [composant de masque](https://docs.unity3d.com/Manual/script-Mask.html) qui requiert la mémoire tampon de stencil, envisagez d’utiliser [RectMask2D](https://docs.unity3d.com/Manual/script-RectMask2D.html) à la place, ce qui ne nécessite pas la mémoire tampon de stencil et peut donc être utilisé avec un format de *profondeur de 16 bits*.</span><span class="sxs-lookup"><span data-stu-id="01479-173">If using a [Mask component](https://docs.unity3d.com/Manual/script-Mask.html) which requires the stencil buffer, consider using [RectMask2D](https://docs.unity3d.com/Manual/script-RectMask2D.html) instead, which does not require the stencil buffer and thus can be used in conjunction with a *16-bit depth format*.</span></span>

> [!NOTE]
> <span data-ttu-id="01479-174">Pour déterminer rapidement quels objets d’une scène n’écrivent pas dans le tampon de profondeur visuellement, vous pouvez utiliser l’utilitaire de [ *tampon de profondeur de rendu*](../configuration/mixed-reality-configuration-guide.md#editor-utilities) sous les paramètres de l' *éditeur* dans le profil de configuration MRTK.</span><span class="sxs-lookup"><span data-stu-id="01479-174">To quickly determine which objects in a scene do not write to the depth buffer visually, one can use the [*Render Depth Buffer* utility](../configuration/mixed-reality-configuration-guide.md#editor-utilities) under the *Editor Settings* in the MRTK Configuration profile.</span></span>

### <a name="optimize-mesh-data"></a><span data-ttu-id="01479-175">Optimiser les données de maillage</span><span class="sxs-lookup"><span data-stu-id="01479-175">Optimize Mesh Data</span></span>

<span data-ttu-id="01479-176">Les paramètres d' [optimisation des données de maillage](https://docs.unity3d.com/ScriptReference/PlayerSettings-stripUnusedMeshComponents.html) tentent de supprimer les attributs de vertex inutilisés dans votre application.</span><span class="sxs-lookup"><span data-stu-id="01479-176">The [Optimize Mesh Data](https://docs.unity3d.com/ScriptReference/PlayerSettings-stripUnusedMeshComponents.html) settings tries to remove unused vertex attributes within your application.</span></span> <span data-ttu-id="01479-177">Pour ce faire, le paramètre s’exécute sur chaque passage de nuanceur dans chaque matériau de chaque maillage de la Build.</span><span class="sxs-lookup"><span data-stu-id="01479-177">The setting performs this by running over every shader pass in every material that is on every mesh in the build.</span></span> <span data-ttu-id="01479-178">Cela convient à la taille des données de jeu et aux performances d’exécution, mais peut nuire considérablement aux temps de génération.</span><span class="sxs-lookup"><span data-stu-id="01479-178">This is good for game data size and runtime performance but can drastically hinder build times.</span></span>

<span data-ttu-id="01479-179">Il est recommandé de désactiver ce paramètre pendant le développement et de le réactiver pendant la création de la build « Master ».</span><span class="sxs-lookup"><span data-stu-id="01479-179">It is recommended to disable this setting during development and re-enable during "Master" build creation.</span></span> <span data-ttu-id="01479-180">Le paramètre se trouve sous **modifier** les  >  **paramètres du projet**  >  **lecteur**  >  **autres paramètres**  >  **optimiser le maillage des données**.</span><span class="sxs-lookup"><span data-stu-id="01479-180">The setting can be found under **Edit** > **Project Settings** > **Player** > **Other Settings** > **Optimize Mesh Data**.</span></span>

## <a name="general-recommendations"></a><span data-ttu-id="01479-181">Recommandations générales</span><span class="sxs-lookup"><span data-stu-id="01479-181">General recommendations</span></span>

<span data-ttu-id="01479-182">Les performances peuvent être un défi en constante évolution pour les développeurs de réalité mixte et le spectre des connaissances pour rationaliser les performances.</span><span class="sxs-lookup"><span data-stu-id="01479-182">Performance can be an ambiguous and constantly changing challenge for mixed reality developers and the spectrum of knowledge to rationalize performance is vast.</span></span> <span data-ttu-id="01479-183">Toutefois, il existe des recommandations générales pour comprendre comment aborder les performances d’une application.</span><span class="sxs-lookup"><span data-stu-id="01479-183">There are some general recommendations for understanding how to approach performance for an application though.</span></span>

<span data-ttu-id="01479-184">Il est utile de simplifier l’exécution d’une application dans les éléments qui s’exécutent sur le *processeur* ou le *GPU* et, par conséquent, de déterminer si une application est limitée par l’un ou l’autre des composants.</span><span class="sxs-lookup"><span data-stu-id="01479-184">It is useful to simplify the execution of an application into the pieces that run on the *CPU* or the *GPU* and thus identify whether an app is bounded by either component.</span></span>  <span data-ttu-id="01479-185">Il peut y avoir des goulots d’étranglement qui couvrent les unités de traitement et certains scénarios uniques qui doivent être soigneusement étudiés.</span><span class="sxs-lookup"><span data-stu-id="01479-185">There can be bottlenecks that span both processing units and some unique scenarios that have to be carefully investigated.</span></span> <span data-ttu-id="01479-186">Toutefois, pour la prise en main, il est judicieux de comprendre où une application s’exécute le plus longtemps.</span><span class="sxs-lookup"><span data-stu-id="01479-186">However, for getting started, it is good to grasp where an application is executing for the most amount of time.</span></span>

### <a name="gpu-bounded"></a><span data-ttu-id="01479-187">Processeur graphique limité</span><span class="sxs-lookup"><span data-stu-id="01479-187">GPU bounded</span></span>

<span data-ttu-id="01479-188">Étant donné que la plupart des plateformes pour les applications de réalité mixte utilisent le [rendu stéréoscopique](https://en.wikipedia.org/wiki/Stereoscopy), il est très courant de les délimiter par GPU en raison de la nature du rendu d’un écran « à deux larges ».</span><span class="sxs-lookup"><span data-stu-id="01479-188">Since most platforms for mixed reality applications are utilizing [stereoscopic rendering](https://en.wikipedia.org/wiki/Stereoscopy), it is very common to be GPU-bounded due to the nature of rendering a "double-wide" screen.</span></span> <span data-ttu-id="01479-189">Futhermore, les plateformes de réalité mixte mobile, telles que HoloLens ou Oculus Quest, sont limitées par le processeur de classe mobile & la puissance de traitement du GPU.</span><span class="sxs-lookup"><span data-stu-id="01479-189">Futhermore, mobile mixed reality platforms such as HoloLens or Oculus Quest will be limited by mobile-class CPU & GPU processing power.</span></span>

<span data-ttu-id="01479-190">Lorsque vous vous concentrez sur le GPU, il y a généralement deux étapes importantes qu’une application doit effectuer pour chaque trame.</span><span class="sxs-lookup"><span data-stu-id="01479-190">When focusing on the GPU, there are generally two important stages that an application must complete every frame.</span></span>

1. <span data-ttu-id="01479-191">Exécuter le [nuanceur de sommets](https://en.wikipedia.org/wiki/Shader#Vertex_shaders)</span><span class="sxs-lookup"><span data-stu-id="01479-191">Execute the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders)</span></span>
2. <span data-ttu-id="01479-192">Exécuter le [nuanceur de pixels](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) (également appelé nuanceur de fragments)</span><span class="sxs-lookup"><span data-stu-id="01479-192">Execute the [pixel shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) (also known as the fragment shader)</span></span>

<span data-ttu-id="01479-193">Sans plongée dans le champ complexe de l’ordinateur Graphics & de [rendu des pipelines](https://en.wikipedia.org/wiki/Graphics_pipeline), chaque étape de nuanceur est un programme qui s’exécute sur le GPU pour produire les éléments suivants.</span><span class="sxs-lookup"><span data-stu-id="01479-193">Without deep diving into the complex field of computer graphics & [rendering pipelines](https://en.wikipedia.org/wiki/Graphics_pipeline), each shader stage is a program that runs on the GPU to produce the following.</span></span>

1. <span data-ttu-id="01479-194">Les nuanceurs vertex transforment les vertex de maillage en coordonnées dans l’espace écran (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="01479-194">Vertex shaders transform mesh vertices to coordinates in screen-space (i.e</span></span> <span data-ttu-id="01479-195">code exécuté par vertex)</span><span class="sxs-lookup"><span data-stu-id="01479-195">code executed per vertex)</span></span>
2. <span data-ttu-id="01479-196">Les nuanceurs de pixels calculent la couleur à dessiner pour un fragment de pixel et de maille donné (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="01479-196">Pixel shaders calculate the color to draw for a given pixel and mesh fragment (i.e</span></span> <span data-ttu-id="01479-197">exécution de code par pixel)</span><span class="sxs-lookup"><span data-stu-id="01479-197">code execute per pixel)</span></span>

<span data-ttu-id="01479-198">En ce qui concerne le réglage des performances, il est généralement plus fructueuse de se concentrer sur l’optimisation des opérations dans le nuanceur de pixels.</span><span class="sxs-lookup"><span data-stu-id="01479-198">In regards to performance tuning, it is usually more fruitful to focus on optimizing the operations in the pixel shader.</span></span> <span data-ttu-id="01479-199">Une application peut uniquement avoir à dessiner un cube qui aura uniquement 8 vertex.</span><span class="sxs-lookup"><span data-stu-id="01479-199">An application may only need to draw a cube which will just be 8 vertices.</span></span> <span data-ttu-id="01479-200">Toutefois, l’espace d’écran occupé par le cube est probablement de l’ordre de millions de pixels.</span><span class="sxs-lookup"><span data-stu-id="01479-200">However, the screen space that cube occupies is likely on the order of millions of pixels.</span></span> <span data-ttu-id="01479-201">Ainsi, la réduction du code du nuanceur de 10 opérations peut faire gagner beaucoup plus de travail s’il est réduit sur le nuanceur de pixels que le nuanceur de sommets.</span><span class="sxs-lookup"><span data-stu-id="01479-201">Thus, reducing shader code by say 10 operations can save significantly more work if reduced on the pixel shader than the vertex shader.</span></span>

<span data-ttu-id="01479-202">C’est l’une des principales raisons pour tirer parti du [nuanceur standard MRTK](../features/rendering/mrtk-standard-shader.md) , car ce nuanceur exécute généralement beaucoup moins d’instructions par pixel & vertex que le nuanceur standard Unity, tout en obtenant des résultats esthétiques comparables.</span><span class="sxs-lookup"><span data-stu-id="01479-202">This is one of the primary reasons for leveraging the [MRTK Standard shader](../features/rendering/mrtk-standard-shader.md) as this shader generally executes many less instructions per pixel & vertex than the Unity Standard shader while achieving comparable aesthetic results.</span></span>

|    <span data-ttu-id="01479-203">Optimisations de l’UC</span><span class="sxs-lookup"><span data-stu-id="01479-203">CPU Optimizations</span></span>      |             <span data-ttu-id="01479-204">Optimisations GPU</span><span class="sxs-lookup"><span data-stu-id="01479-204">GPU Optimizations</span></span>              |
|---------------------------|--------------------------------------------|
| <span data-ttu-id="01479-205">Logique de simulation d’application</span><span class="sxs-lookup"><span data-stu-id="01479-205">App simulation logic</span></span>      | <span data-ttu-id="01479-206">Opérations de rendu</span><span class="sxs-lookup"><span data-stu-id="01479-206">Rendering operations</span></span> |
| <span data-ttu-id="01479-207">Simplifier la physique</span><span class="sxs-lookup"><span data-stu-id="01479-207">Simplify Physics</span></span>          | <span data-ttu-id="01479-208">Réduire les calculs d’éclairage</span><span class="sxs-lookup"><span data-stu-id="01479-208">Reduce lighting calculations</span></span> |
| <span data-ttu-id="01479-209">Simplifier les animations</span><span class="sxs-lookup"><span data-stu-id="01479-209">Simplify Animations</span></span>       | <span data-ttu-id="01479-210">Réduire le nombre de polygones & nombre d’objets dessinables</span><span class="sxs-lookup"><span data-stu-id="01479-210">Reduce polygon count & # of drawable objects</span></span> |
| <span data-ttu-id="01479-211">Gérer le garbage collection</span><span class="sxs-lookup"><span data-stu-id="01479-211">Manage Garbage Collection</span></span> | <span data-ttu-id="01479-212">Réduire le nombre d’objets transparents</span><span class="sxs-lookup"><span data-stu-id="01479-212">Reduce # of transparent objects</span></span> |
| <span data-ttu-id="01479-213">Références du cache</span><span class="sxs-lookup"><span data-stu-id="01479-213">Cache References</span></span>          | <span data-ttu-id="01479-214">Évitez les effets de traitement/plein écran</span><span class="sxs-lookup"><span data-stu-id="01479-214">Avoid post-processing/full-screen effects</span></span>  |

### <a name="draw-call-instancing"></a><span data-ttu-id="01479-215">Instanciation des appels de dessin</span><span class="sxs-lookup"><span data-stu-id="01479-215">Draw call instancing</span></span>

<span data-ttu-id="01479-216">L’une des erreurs les plus courantes dans Unity qui réduit les performances est le clonage de documents au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="01479-216">One of the most common mistakes in Unity that reduces performance is cloning materials at runtime.</span></span> <span data-ttu-id="01479-217">Si les GameObjects partagent le même matériau et/ou sont le même maillage, ils peuvent être optimisés dans des appels de dessin unique via des techniques telles que le *[traitement par lots statique](https://docs.unity3d.com/Manual/DrawCallBatching.html)*, le *[traitement par lots dynamique](https://docs.unity3d.com/Manual/DrawCallBatching.html)* et l' *[instanciation de GPU](https://docs.unity3d.com/Manual/GPUInstancing.html)*.</span><span class="sxs-lookup"><span data-stu-id="01479-217">If GameObjects share the same material and/or are the same mesh, they can be optimized into single draw calls via techniques such as *[static batching](https://docs.unity3d.com/Manual/DrawCallBatching.html)*, *[dynamic batching](https://docs.unity3d.com/Manual/DrawCallBatching.html)*, and *[GPU Instancing](https://docs.unity3d.com/Manual/GPUInstancing.html)*.</span></span> <span data-ttu-id="01479-218">Toutefois, si le développeur modifie les propriétés du [matériau d’un convertisseur](https://docs.unity3d.com/ScriptReference/Renderer-material.html) lors de l’exécution, Unity crée une copie clone du matériau affecté.</span><span class="sxs-lookup"><span data-stu-id="01479-218">However, if developer's modify properties of a [Renderer's material](https://docs.unity3d.com/ScriptReference/Renderer-material.html) at runtime, Unity will create a clone copy of the assigned material.</span></span>

<span data-ttu-id="01479-219">Par exemple, s’il existe un cube 100 dans une scène, un développeur peut souhaiter affecter une couleur unique à chaque au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="01479-219">For example, if there are a 100 cubes in a scene, a developer may want to assign a unique color to each at runtime.</span></span> <span data-ttu-id="01479-220">L’accès à [*renderr. Material. Color*](https://docs.unity3d.com/ScriptReference/Material-color.html) en C# permet à Unity de créer un nouveau matériau en mémoire pour ce convertisseur/gameobject particulier.</span><span class="sxs-lookup"><span data-stu-id="01479-220">The access of [*renderer.material.color*](https://docs.unity3d.com/ScriptReference/Material-color.html) in C# will make Unity create a new material in memory for this particular renderer/GameObject.</span></span> <span data-ttu-id="01479-221">Chacun des cubes 100 a son propre matériau et ne peut donc pas être fusionné dans un appel de dessin, mais au lieu de cela, il devient 100 demandes d’appel de l’UC au GPU.</span><span class="sxs-lookup"><span data-stu-id="01479-221">Each of the 100 cubes will have its own material and thus they cannot be merged together into one draw call, but instead will become 100 draw call requests from the CPU to the GPU.</span></span>

<span data-ttu-id="01479-222">Pour surmonter cet obstacle tout en affectant une couleur unique par cube, les développeurs doivent tirer parti de [MaterialPropertyBlock](https://docs.unity3d.com/ScriptReference/MaterialPropertyBlock.html).</span><span class="sxs-lookup"><span data-stu-id="01479-222">To overcome this obstacle and still assign a unique color per cube, developers should leverage [MaterialPropertyBlock](https://docs.unity3d.com/ScriptReference/MaterialPropertyBlock.html).</span></span>

```c#
private PropertyBlock m_PropertyBlock ;
private Renderer myRenderer;

private void Start()
{
     myRenderer = GetComponent<Renderer>();
     m_PropertyBlock = new MaterialPropertyBlock();
}

private void ChangeColor()
{
    // Creates a copy of the material once for this renderer
    myRenderer.material.color = Color.red;

    // vs.

    // Retains instancing capability for renderer
    m_PropertyBlock.SetColor("_Color", Color.red);
    myRenderer.SetPropertyBlock(m_PropertyBlock);
}
```

## <a name="unity-performance-tools"></a><span data-ttu-id="01479-223">Outils de performances Unity</span><span class="sxs-lookup"><span data-stu-id="01479-223">Unity performance tools</span></span>

<span data-ttu-id="01479-224">Unity fournit de superbes outils de performances intégrés à l’éditeur.</span><span class="sxs-lookup"><span data-stu-id="01479-224">Unity provides great performance tools that are built into the editor.</span></span>

- [<span data-ttu-id="01479-225">Profileur Unity</span><span class="sxs-lookup"><span data-stu-id="01479-225">Unity Profiler</span></span>](https://docs.unity3d.com/Manual//Profiler.html)
- [<span data-ttu-id="01479-226">Débogueur de frames Unity</span><span class="sxs-lookup"><span data-stu-id="01479-226">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

<span data-ttu-id="01479-227">Si vous évaluez le compromis approximatif des performances entre un nuanceur et un autre, il est utile de compiler chaque nuanceur et d’afficher le nombre d’opérations par étape de nuanceur.</span><span class="sxs-lookup"><span data-stu-id="01479-227">If estimating the rough performance tradeoff between one shader and another, it is useful to compile each shader and view the number of operations per shader stage.</span></span> <span data-ttu-id="01479-228">Pour ce faire, sélectionnez une [ressource de nuanceur](https://docs.unity3d.com/Manual/class-Shader.html) et cliquez sur le bouton *compiler et afficher le code* .</span><span class="sxs-lookup"><span data-stu-id="01479-228">This can be done by selecting a [shader asset](https://docs.unity3d.com/Manual/class-Shader.html) and clicking the *Compile and show code* button.</span></span> <span data-ttu-id="01479-229">Cela permet de compiler toutes les variantes du nuanceur et d’ouvrir Visual Studio avec les résultats.</span><span class="sxs-lookup"><span data-stu-id="01479-229">This will compile all the shader variants and open visual studio with the results.</span></span> <span data-ttu-id="01479-230">Remarque : les résultats des statistiques produits peuvent varier selon les fonctionnalités qui ont été activées sur les matériaux utilisant le nuanceur donné.</span><span class="sxs-lookup"><span data-stu-id="01479-230">Note: The statistic results produced may vary depending on what features have been enabled on materials utilizing the given shader.</span></span> <span data-ttu-id="01479-231">Unity compile uniquement les variantes de nuanceur qui sont directement utilisées dans le projet actuel.</span><span class="sxs-lookup"><span data-stu-id="01479-231">Unity will only compile the shader variants being directly used in the current project.</span></span>

<span data-ttu-id="01479-232">Exemple de statistiques de nuanceur standard Unity</span><span class="sxs-lookup"><span data-stu-id="01479-232">Unity Standard shader statistics example</span></span>

![Statistiques de nuanceur standard Unity 1](../features/images/performance/UnityStandardShader-Stats.PNG)

<span data-ttu-id="01479-234">Exemple de statistiques de nuanceur standard MRTK</span><span class="sxs-lookup"><span data-stu-id="01479-234">MRTK Standard shader statistics example</span></span>

![Statistiques de nuanceur standard MRTK 2](../features/images/performance/MRTKStandardShader-Stats.PNG)

## <a name="see-also"></a><span data-ttu-id="01479-236">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="01479-236">See also</span></span>

### <a name="unity"></a><span data-ttu-id="01479-237">Unity</span><span class="sxs-lookup"><span data-stu-id="01479-237">Unity</span></span>

- [<span data-ttu-id="01479-238">Optimisation des performances Unity pour les débutants</span><span class="sxs-lookup"><span data-stu-id="01479-238">Unity Performance Optimization for Beginners</span></span>](https://www.youtube.com/watch?v=1e5WY2qf600)
- [<span data-ttu-id="01479-239">Didacticiels sur l’optimisation des performances Unity</span><span class="sxs-lookup"><span data-stu-id="01479-239">Unity Performance Optimization Tutorials</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization)
- [<span data-ttu-id="01479-240">Meilleures pratiques pour l’optimisation Unity</span><span class="sxs-lookup"><span data-stu-id="01479-240">Unity Optimization Best Practices</span></span>](https://docs.unity3d.com/Documentation/Manual/BestPracticeUnderstandingPerformanceInUnity.html)
- [<span data-ttu-id="01479-241">Optimisation des performances graphiques</span><span class="sxs-lookup"><span data-stu-id="01479-241">Optimizing graphics performance</span></span>](https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)
- [<span data-ttu-id="01479-242">Guide pratique de l’optimisation mobile</span><span class="sxs-lookup"><span data-stu-id="01479-242">Mobile Optimization Practical Guide</span></span>](https://docs.unity3d.com/Manual/MobileOptimizationPracticalGuide.html)

### <a name="windows-mixed-reality"></a><span data-ttu-id="01479-243">Windows Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="01479-243">Windows Mixed Reality</span></span>

- [<span data-ttu-id="01479-244">Paramètres recommandés pour Unity</span><span class="sxs-lookup"><span data-stu-id="01479-244">Recommended Settings for Unity</span></span>](/windows/mixed-reality/recommended-settings-for-unity)
- [<span data-ttu-id="01479-245">Comprendre les performances de la réalité mixte</span><span class="sxs-lookup"><span data-stu-id="01479-245">Understanding Performance for Mixed Reality</span></span>](/windows/mixed-reality/understanding-performance-for-mixed-reality)
- [<span data-ttu-id="01479-246">Recommandations de performances pour Unity</span><span class="sxs-lookup"><span data-stu-id="01479-246">Performance recommendations for Unity</span></span>](/windows/mixed-reality/performance-recommendations-for-unity)
- [<span data-ttu-id="01479-247">Guide de Suivi d’v nements pour Windows Unity</span><span class="sxs-lookup"><span data-stu-id="01479-247">Event Tracing for Windows Unity Guide</span></span>](https://docs.unity3d.com/uploads/ExpertGuides/Analyzing_your_game_performance_using_Event_Tracing_for_Windows.pdf)

### <a name="oculus"></a><span data-ttu-id="01479-248">Oculus</span><span class="sxs-lookup"><span data-stu-id="01479-248">Oculus</span></span>

- [<span data-ttu-id="01479-249">Recommandations relatives aux performances</span><span class="sxs-lookup"><span data-stu-id="01479-249">Performance Guidelines</span></span>](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-guidelines/)
- [<span data-ttu-id="01479-250">Outils pour les performances</span><span class="sxs-lookup"><span data-stu-id="01479-250">Performance Tools</span></span>](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance-tools/)

### <a name="mesh-optimization"></a><span data-ttu-id="01479-251">Optimisation du maillage</span><span class="sxs-lookup"><span data-stu-id="01479-251">Mesh optimization</span></span>

- [<span data-ttu-id="01479-252">Optimiser les modèles 3D</span><span class="sxs-lookup"><span data-stu-id="01479-252">Optimize 3D models</span></span>](/dynamics365/mixed-reality/import-tool/optimize-models#performance-targets)
- [<span data-ttu-id="01479-253">Meilleures pratiques pour la conversion et l’optimisation des modèles 3D en temps réel</span><span class="sxs-lookup"><span data-stu-id="01479-253">Best practices for converting and optimizing real-time 3D models</span></span>](/dynamics365/mixed-reality/import-tool/best-practices)