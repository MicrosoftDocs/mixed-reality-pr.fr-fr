---
title: Vue d'ensemble des résolveurs
description: Vue d’ensemble des résolveurs dans MRTK
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
ms.localizationpriority: high
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, développement, MRTK, résolveurs
ms.openlocfilehash: bf9bbfe578ace576fca8870f038f145037a6838d
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/01/2021
ms.locfileid: "113176457"
---
# <a name="solver-overview"></a><span data-ttu-id="96d7f-104">Vue d'ensemble des résolveurs</span><span class="sxs-lookup"><span data-stu-id="96d7f-104">Solver overview</span></span>

![Résolveur principal](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="96d7f-106">Les résolveurs sont des composants qui facilitent le calcul de la position d’un objet et l’orientation en fonction d’un algorithme prédéfini.</span><span class="sxs-lookup"><span data-stu-id="96d7f-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefined algorithm.</span></span> <span data-ttu-id="96d7f-107">Il est par exemple possible de placer un objet sur la surface actuellement visée par le raycast du pointage du regard de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>

<span data-ttu-id="96d7f-108">En outre, le système de résolveur définit de manière déterministe un ordre des opérations pour ces calculs de transformation, car il n’existe pas de méthode fiable pour indiquer à Unity l’ordre de mise à jour des composants.</span><span class="sxs-lookup"><span data-stu-id="96d7f-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="96d7f-109">Les résolveurs offrent un éventail de comportements pour attacher des objets à d’autres objets ou systèmes.</span><span class="sxs-lookup"><span data-stu-id="96d7f-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="96d7f-110">Un autre exemple est un objet tag-along qui pointe vers l’avant de l’utilisateur (en fonction de l’appareil photo).</span><span class="sxs-lookup"><span data-stu-id="96d7f-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="96d7f-111">Un résolveur peut également être attaché à un contrôleur et à un objet pour faire de l’objet tag-along le contrôleur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="96d7f-112">Tous les résolveurs peuvent être empilés en toute sécurité, par exemple un comportement avec objet tag-along + aimantation de surface + dynamisme.</span><span class="sxs-lookup"><span data-stu-id="96d7f-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="96d7f-113">Comment utiliser un résolveur</span><span class="sxs-lookup"><span data-stu-id="96d7f-113">How to use a solver</span></span>

<span data-ttu-id="96d7f-114">Le système du résolveur se compose de trois catégories de scripts :</span><span class="sxs-lookup"><span data-stu-id="96d7f-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="96d7f-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver) : classe abstraite de base de laquelle tous les résolveurs dérivent.</span><span class="sxs-lookup"><span data-stu-id="96d7f-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="96d7f-116">Elle fournit le suivi d’état, les paramètres de lissage et l’implémentation, l’intégration du système de résolveur automatique et l’ordre des mises à jour.</span><span class="sxs-lookup"><span data-stu-id="96d7f-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="96d7f-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) : définit l’objet de référence selon lequel assurer le suivi (par exemple, la transformation de la caméra principale, le rayon émanant de la main, etc.), gère la collecte des composants du résolveur et exécute leur mise à jour dans l’ordre approprié.</span><span class="sxs-lookup"><span data-stu-id="96d7f-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="96d7f-118">La troisième catégorie est le résolveur lui-même.</span><span class="sxs-lookup"><span data-stu-id="96d7f-118">The third category is the solver itself.</span></span> <span data-ttu-id="96d7f-119">Les résolveurs suivants fournissent les blocs de construction pour le comportement de base :</span><span class="sxs-lookup"><span data-stu-id="96d7f-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="96d7f-120">[`Orbital`](#orbital) : verrouille sur une position et un offset spécifiés à partir de l’objet référencé.</span><span class="sxs-lookup"><span data-stu-id="96d7f-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="96d7f-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize) : met à l’échelle pour conserver une taille constante relative à la vue de l’objet référencé.</span><span class="sxs-lookup"><span data-stu-id="96d7f-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="96d7f-122">[`RadialView`](#radialview) : conserve l’objet dans une vue de type cône converti par l’objet référencé.</span><span class="sxs-lookup"><span data-stu-id="96d7f-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="96d7f-123">[`Follow`](#follow) : conserve l’objet dans un ensemble de limites définies par l’utilisateur de l’objet référencé.</span><span class="sxs-lookup"><span data-stu-id="96d7f-123">[`Follow`](#follow): Keeps the object within a set of user defined bounds of the referenced object.</span></span>
* <span data-ttu-id="96d7f-124">[`InBetween`](#inbetween) : conserve un objet entre deux objets suivis.</span><span class="sxs-lookup"><span data-stu-id="96d7f-124">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="96d7f-125">[`SurfaceMagnetism`](#surfacemagnetism) : convertit les rayons en surfaces dans le monde et aligne l’objet sur cette surface.</span><span class="sxs-lookup"><span data-stu-id="96d7f-125">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="96d7f-126">[`DirectionalIndicator`](#directionalindicator) : détermine la position et l’orientation d’un objet sous la forme d’un indicateur directionnel.</span><span class="sxs-lookup"><span data-stu-id="96d7f-126">[`DirectionalIndicator`](#directionalindicator): Determines the position and orientation of an object as a directional indicator.</span></span> <span data-ttu-id="96d7f-127">À partir du point de référence de la cible suivie SolverHandler, cet indicateur va orienter vers la DirectionalTarget fournie.</span><span class="sxs-lookup"><span data-stu-id="96d7f-127">From the point of reference of the SolverHandler Tracked Target, this indicator will orient towards the DirectionalTarget supplied.</span></span>
* <span data-ttu-id="96d7f-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum) : applique l’accélération/la vélocité/la friction pour simuler le dynamisme et les souplesse d’un objet déplacé par d’autres résolveurs/composants.</span><span class="sxs-lookup"><span data-stu-id="96d7f-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="96d7f-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup) : limite l’objet pour suivre les mains dans une région qui ne croise pas le GameObject avec les mains.</span><span class="sxs-lookup"><span data-stu-id="96d7f-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="96d7f-130">Utile pour le contenu interactif à la main, comme les menus, etc. Ce solveur est conçu pour fonctionner avec [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) , mais il fonctionne également avec [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span><span class="sxs-lookup"><span data-stu-id="96d7f-130">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="96d7f-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup) : dérive de HandConstraint mais comprend une logique permettant de tester si la paume fait face à l’utilisateur avant l’activation.</span><span class="sxs-lookup"><span data-stu-id="96d7f-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="96d7f-132">Ce résolveur fonctionne uniquement avec les contrôleurs [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand), avec d’autres types de contrôleur. ce résolveur se comporte comme sa classe de base.</span><span class="sxs-lookup"><span data-stu-id="96d7f-132">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="96d7f-133">Pour utiliser le système du résolveur, ajoutez simplement l’un des composants repris ci-dessus à un GameObject.</span><span class="sxs-lookup"><span data-stu-id="96d7f-133">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="96d7f-134">Étant donné que tous les résolveurs requièrent un(e) [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), il y en a un(e) qui est créé(e) automatiquement par Unity.</span><span class="sxs-lookup"><span data-stu-id="96d7f-134">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="96d7f-135">Vous trouverez des exemples d’utilisation du système de résolveurs dans le fichier **SolverExamples.scene**.</span><span class="sxs-lookup"><span data-stu-id="96d7f-135">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="96d7f-136">Comment modifier la référence de suivi</span><span class="sxs-lookup"><span data-stu-id="96d7f-136">How to change tracking reference</span></span>

<span data-ttu-id="96d7f-137">La propriété *Tracked Target Type* du composant [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) définit le point de référence que tous les résolveurs utiliseront pour calculer leurs algorithmes.</span><span class="sxs-lookup"><span data-stu-id="96d7f-137">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="96d7f-138">Par exemple, un type valeur de [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) avec un composant [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) simple se traduira par un raycast à partir de la tête et dans la direction du pointage du regard de l’utilisateur pour déterminer la surface atteinte.</span><span class="sxs-lookup"><span data-stu-id="96d7f-138">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="96d7f-139">Les valeurs potentielles pour la propriété `TrackedTargetType` sont :</span><span class="sxs-lookup"><span data-stu-id="96d7f-139">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="96d7f-140">*Head* : le point de référence est la transformation de la caméra principale</span><span class="sxs-lookup"><span data-stu-id="96d7f-140">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="96d7f-141">*ControllerRay* : le point de référence est la transformation [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) sur un contrôleur (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="96d7f-141">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="96d7f-142">origine du pointeur sur un contrôleur de mouvement ou un contrôleur de main) pointant dans la direction du rayon de la ligne</span><span class="sxs-lookup"><span data-stu-id="96d7f-142">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="96d7f-143">Utilisez la propriété `TrackedHandedness` pour sélectionner la préférence de main (par exemple,</span><span class="sxs-lookup"><span data-stu-id="96d7f-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="96d7f-144">gaucher, droitier, ambidextre)</span><span class="sxs-lookup"><span data-stu-id="96d7f-144">Left, Right, Both)</span></span>
* <span data-ttu-id="96d7f-145">*HandJoint* : le point de référence est la transformation d’une articulation de la main spécifique</span><span class="sxs-lookup"><span data-stu-id="96d7f-145">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="96d7f-146">Utilisez la propriété `TrackedHandedness` pour sélectionner la préférence de main (par exemple,</span><span class="sxs-lookup"><span data-stu-id="96d7f-146">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="96d7f-147">gaucher, droitier, ambidextre)</span><span class="sxs-lookup"><span data-stu-id="96d7f-147">Left, Right, Both)</span></span>
  * <span data-ttu-id="96d7f-148">Utilisez la propriété `TrackedHandJoint` pour déterminer la transformation d’articulation à utiliser</span><span class="sxs-lookup"><span data-stu-id="96d7f-148">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="96d7f-149">*CustomOverride* : point de référence depuis le/la `TransformOverride` affecté(e)</span><span class="sxs-lookup"><span data-stu-id="96d7f-149">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="96d7f-150">Pour les types *ControllerRay* et *HandJoint*, le gestionnaire de résolveur tentera de fournir d’abord la transformation de contrôleur/main gauche, puis du droit si le premier n’est pas disponible ou à moins que la propriété `TrackedHandedness` spécifie autre chose.</span><span class="sxs-lookup"><span data-stu-id="96d7f-150">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="96d7f-151">![Objet suivi du résolveur](../../images/solver/TrackedObjectType-Example.gif) 
*Exemple de propriétés variées associées à chaque TrackedTargetType*</span><span class="sxs-lookup"><span data-stu-id="96d7f-151">![Solver Tracked Object](../../images/solver/TrackedObjectType-Example.gif) 
*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="96d7f-152">La plupart des résolveurs utilisent le vecteur vers l’avant de la cible de transformation suivie fournie par `SolverHandler`.</span><span class="sxs-lookup"><span data-stu-id="96d7f-152">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="96d7f-153">Lors de l’utilisation d’un type de cible *Articulation de la main* suivi, le vecteur avant de l’articulation de la paume peut pointer avec les doigts et non avec la paume.</span><span class="sxs-lookup"><span data-stu-id="96d7f-153">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="96d7f-154">Cela dépend de la plateforme fournissant les données jointes à la main.</span><span class="sxs-lookup"><span data-stu-id="96d7f-154">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="96d7f-155">Pour la simulation d’entrée et Windows Mixed Reality, c’est le *vecteur vers le haut* qui pointe vers la paume (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="96d7f-155">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="96d7f-156">le vecteur vert est vers le haut, le vecteur bleu est vers l’avant).</span><span class="sxs-lookup"><span data-stu-id="96d7f-156">green vector is up, blue vector is forward).</span></span>
>
> ![Transférer le vecteur vers le haut](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="96d7f-158">Pour remédier à cela, mettez à jour la propriété *Rotation supplémentaire* sur le/la `SolverHandler` pour **<90, 0,0>** .</span><span class="sxs-lookup"><span data-stu-id="96d7f-158">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="96d7f-159">Cela permet de s’assurer que le vecteur direct fourni aux résolveurs pointe via la paume et vers l’extérieur de la main.</span><span class="sxs-lookup"><span data-stu-id="96d7f-159">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![Rotation supplémentaire](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="96d7f-161">Vous pouvez également utiliser le type de cible *Ray Controller* suivi pour obtenir un comportement similaire pour le pointage avec les mains.</span><span class="sxs-lookup"><span data-stu-id="96d7f-161">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="96d7f-162">Comment joindre des résolveurs</span><span class="sxs-lookup"><span data-stu-id="96d7f-162">How to chain solvers</span></span>

<span data-ttu-id="96d7f-163">Il est possible d’ajouter plusieurs composants `Solver` au même GameObject, et ainsi de joindre leurs algorithmes.</span><span class="sxs-lookup"><span data-stu-id="96d7f-163">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="96d7f-164">Les composants `SolverHandler` gèrent la mise à jour de tous les résolveurs sur le même GameObject.</span><span class="sxs-lookup"><span data-stu-id="96d7f-164">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="96d7f-165">Par défaut, les `SolverHandler` appels `GetComponents<Solver>()` à Start retournent les résolveurs dans l’ordre dans lequel ils apparaissent dans l’inspecteur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-165">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="96d7f-166">En outre, l’affectation de la valeur true à la propriété *Updated Linked Transform* indique ce/cette `Solver` pour enregistrer sa position calculée, son orientation et son échelle calculées vers une variable intermédiaire accessible par tous les résolveurs (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="96d7f-166">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="96d7f-167">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="96d7f-167">`GoalPosition`).</span></span> <span data-ttu-id="96d7f-168">Quand la valeur est false, le/la `Solver` met directement à jour la transformation de GameObject.</span><span class="sxs-lookup"><span data-stu-id="96d7f-168">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="96d7f-169">En enregistrant les propriétés de transformation dans un emplacement intermédiaire, les autres résolveurs sont en mesure d’effectuer leurs calculs à partir de la variable intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="96d7f-169">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="96d7f-170">En effet, Unity ne permet pas aux mises à jour de gameObject.transform de s’empiler dans le même cadre.</span><span class="sxs-lookup"><span data-stu-id="96d7f-170">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="96d7f-171">Les développeurs peuvent modifier l’ordre d’exécution des résolveurs en définissant la propriété `SolverHandler.Solvers` directement.</span><span class="sxs-lookup"><span data-stu-id="96d7f-171">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="96d7f-172">Création d'un résolveur</span><span class="sxs-lookup"><span data-stu-id="96d7f-172">How to create a new solver</span></span>

<span data-ttu-id="96d7f-173">Tous les résolveurs doivent hériter de la classe de base abstraite, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver) .</span><span class="sxs-lookup"><span data-stu-id="96d7f-173">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="96d7f-174">Les exigences principales d’une extension du résolveur impliquent la substitution de la méthode `SolverUpdate`.</span><span class="sxs-lookup"><span data-stu-id="96d7f-174">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="96d7f-175">Dans cette méthode, les développeurs doivent mettre à jour les propriétés héritées `GoalPosition`, `GoalRotation` et `GoalScale` avec les valeurs souhaitées.</span><span class="sxs-lookup"><span data-stu-id="96d7f-175">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="96d7f-176">En outre, il est généralement utile de tirer parti de `SolverHandler.TransformTarget` comme cadre de référence souhaité par le consommateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-176">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="96d7f-177">Le code fourni ci-dessous donne un exemple d’un nouveau composant de résolveur appelé `InFront` qui place l’objet attaché à deux mètres devant le/la `SolverHandler.TransformTarget` .</span><span class="sxs-lookup"><span data-stu-id="96d7f-177">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="96d7f-178">Si le/la `SolverHandler.TrackedTargetType` est défini(e) par le consommateur en tant que [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), le/la `SolverHandler.TransformTarget` sera la transformation de la caméra et, par conséquent, ce résolveur placera le GameObject en pièce jointe à deux mètres en face du point de regard de chaque cadre des utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="96d7f-178">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="96d7f-179">Guides d’implémentation du résolveur</span><span class="sxs-lookup"><span data-stu-id="96d7f-179">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="96d7f-180">Propriétés courantes du résolveur</span><span class="sxs-lookup"><span data-stu-id="96d7f-180">Common solver properties</span></span>

<span data-ttu-id="96d7f-181">Chaque composant du résolveur possède un ensemble de propriétés identiques qui contrôlent le comportement du résolveur principal.</span><span class="sxs-lookup"><span data-stu-id="96d7f-181">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="96d7f-182">Si le *lissage* est activé, le résolveur met progressivement à jour la transformation du GameObject au fil du temps sur les valeurs calculées.</span><span class="sxs-lookup"><span data-stu-id="96d7f-182">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="96d7f-183">La vitesse de cette modification est déterminée par la propriété *LerpTime* de chaque composant de transformation.</span><span class="sxs-lookup"><span data-stu-id="96d7f-183">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="96d7f-184">Par exemple, une valeur *MoveLerpTime* supérieure entraîne des incréments plus lents entre les cadres.</span><span class="sxs-lookup"><span data-stu-id="96d7f-184">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="96d7f-185">Si *MaintainScale* est activé, le résolveur utilisera l’échelle locale par défaut de GameObject.</span><span class="sxs-lookup"><span data-stu-id="96d7f-185">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="96d7f-186">![Propriétés du résolveur principal](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="96d7f-186">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="96d7f-187">*Propriétés communes héritées par tous les composants du résolveur*</span><span class="sxs-lookup"><span data-stu-id="96d7f-187">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="96d7f-188">Orbital</span><span class="sxs-lookup"><span data-stu-id="96d7f-188">Orbital</span></span>

<span data-ttu-id="96d7f-189">La classe [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) est un composant tag-along qui se comporte comme des planètes dans un système solaire.</span><span class="sxs-lookup"><span data-stu-id="96d7f-189">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="96d7f-190">Ce solveur garantit que le GameObject joint orbite autour de la transformation suivie.</span><span class="sxs-lookup"><span data-stu-id="96d7f-190">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="96d7f-191">Ainsi, si le *Tracked Target Type* du/de la [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) est défini sur [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), le GameObject orbite autour de la tête de l’utilisateur avec un décalage fixe appliqué.</span><span class="sxs-lookup"><span data-stu-id="96d7f-191">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="96d7f-192">Les développeurs peuvent modifier ce décalage fixe pour conserver des menus ou d’autres composants de scène au niveau de l’œil ou au niveau de la taille, etc. autour d’un utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-192">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="96d7f-193">Cela est effectué par la modification des propriétés *Local Offset* et *World Offset* .</span><span class="sxs-lookup"><span data-stu-id="96d7f-193">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="96d7f-194">La propriété *Orientation Type* détermine la rotation appliquée à l’objet s’il doit conserver sa rotation d’origine, ou s’il doit toujours faire face à la caméra ou à la transformation qui dirige sa position, etc.</span><span class="sxs-lookup"><span data-stu-id="96d7f-194">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="96d7f-195">![Exemple orbital](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="96d7f-195">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="96d7f-196">*Exemple orbital*</span><span class="sxs-lookup"><span data-stu-id="96d7f-196">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="96d7f-197">RadialView</span><span class="sxs-lookup"><span data-stu-id="96d7f-197">RadialView</span></span>

<span data-ttu-id="96d7f-198">Le/la [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) est un autre composant tag-along qui conserve une portion spécifique d’un GameObject dans le tronc de cône de la vue de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-198">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="96d7f-199">Les propriétés *Min & Max View Degrees* déterminent la taille qu’une partie du GameObject doit toujours avoir dans la vue.</span><span class="sxs-lookup"><span data-stu-id="96d7f-199">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="96d7f-200">Les propriétés *Min &amp; Max distance* déterminent la durée pendant laquelle le GameObject doit être conservé par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-200">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="96d7f-201">Par exemple, si vous parcourez le GameObject avec une *Distance minimale* d’un mètre, vous éloignez le GameObject pour vous assurer qu’il n’est jamais plus proche qu’un mètre par rapport à l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-201">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="96d7f-202">En règle générale, le/la [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) est utilisé(e) conjointement avec la propriété *Tracked Target Type* définie sur [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) afin que le composant suive le pointage du regard de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-202">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="96d7f-203">Toutefois, ce composant peut fonctionner pour être conservé dans la *« vue »* de n’importe quel *Tracked Target Type*.</span><span class="sxs-lookup"><span data-stu-id="96d7f-203">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="96d7f-204">![Exemple RadialView](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="96d7f-204">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="96d7f-205">*Exemple RadialView*</span><span class="sxs-lookup"><span data-stu-id="96d7f-205">*RadialView example*</span></span>

### <a name="follow"></a><span data-ttu-id="96d7f-206">Suivi</span><span class="sxs-lookup"><span data-stu-id="96d7f-206">Follow</span></span>

<span data-ttu-id="96d7f-207">La classe [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) positionne un élément devant la cible suivie par rapport à son axe de transfert local.</span><span class="sxs-lookup"><span data-stu-id="96d7f-207">The [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) class positions an element in front of the of the tracked target relative to its local forward axis.</span></span> <span data-ttu-id="96d7f-208">L’élément peut être faiblement contraint (également appelé</span><span class="sxs-lookup"><span data-stu-id="96d7f-208">The element can be loosely constrained (a.k.a.</span></span> <span data-ttu-id="96d7f-209">tag-along) afin qu’il ne soit pas suivi jusqu’à ce que la cible suivie passe au-delà des limites définies par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-209">tag-along) so that it doesn't follow until the tracked target moves beyond user defined bounds.</span></span>

<span data-ttu-id="96d7f-210">Il fonctionne de la même façon que le résolveur RadialView, avec des contrôles supplémentaires pour gérer le *nombre maximal de niveaux d’affichage verticaux et horizontaux* et des mécanismes permettant de modifier l'*orientation* de l’objet.</span><span class="sxs-lookup"><span data-stu-id="96d7f-210">It works similarly to the RadialView solver, with additional controls to manage *Max Horizontal & Vertical View Degrees*, and mechanisms to alter the *Orientation* of the object.</span></span>

<span data-ttu-id="96d7f-211">![Suivre les propriétés](../../images/solver/FollowExample.png)</span><span class="sxs-lookup"><span data-stu-id="96d7f-211">![Follow properties](../../images/solver/FollowExample.png)</span></span>  
<span data-ttu-id="96d7f-212">*Suivre les propriétés*</span><span class="sxs-lookup"><span data-stu-id="96d7f-212">*Follow properties*</span></span>

<span data-ttu-id="96d7f-213">![Suivre l’exemple de scène](../../images/solver/FollowExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="96d7f-213">![Follow example scene](../../images/solver/FollowExampleScene.gif)</span></span>  
<span data-ttu-id="96d7f-214">*Suivre l’exemple de scène (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="96d7f-214">*Follow Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span></span>

### <a name="inbetween"></a><span data-ttu-id="96d7f-215">InBetween</span><span class="sxs-lookup"><span data-stu-id="96d7f-215">InBetween</span></span>

<span data-ttu-id="96d7f-216">La classe [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) conserve le gameobject joint entre deux transformations.</span><span class="sxs-lookup"><span data-stu-id="96d7f-216">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="96d7f-217">Ces deux points de terminaison de transformation sont définis par le [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* propre au GameObject et le composant [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) de la propriété *Second Tracked Target Type*.</span><span class="sxs-lookup"><span data-stu-id="96d7f-217">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="96d7f-218">En règle générale, les deux types ont la valeur [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) et les valeurs résultantes `SolverHandler.TransformOverride` et `InBetween.SecondTransformOverride` définies sur les deux points de terminaison suivis.</span><span class="sxs-lookup"><span data-stu-id="96d7f-218">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="96d7f-219">Au moment de l’exécution, le composant [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) crée un autre composant [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) en fonction des propriétés *Second Tracked Target Type* et *Second Transform Override*.</span><span class="sxs-lookup"><span data-stu-id="96d7f-219">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="96d7f-220">Le/la `PartwayOffset` définit l’emplacement de l’objet le long de la ligne entre deux transformations. L’objet doit être placé 0,5 à mi-chemin, 1,0 à la première transformation et 0,0 à la deuxième transformation.</span><span class="sxs-lookup"><span data-stu-id="96d7f-220">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="96d7f-221">![Exemple InBetween](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="96d7f-221">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="96d7f-222">*Exemple d’utilisation d’un solveur InBetween pour conserver l’objet entre deux transformations*</span><span class="sxs-lookup"><span data-stu-id="96d7f-222">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="96d7f-223">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="96d7f-223">SurfaceMagnetism</span></span>

<span data-ttu-id="96d7f-224">Le/la [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) fonctionne en effectuant un raycast sur un LayerMask défini de surfaces et en plaçant le GameObject à ce point de contact.</span><span class="sxs-lookup"><span data-stu-id="96d7f-224">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="96d7f-225">La propriété *Surface Normal Offset* place le GameObject à une distance définie en mètres à l’extérieur de la surface dans la direction normale par rapport au point d’accès de la surface.</span><span class="sxs-lookup"><span data-stu-id="96d7f-225">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="96d7f-226">À l’inverse, la propriété *Surface Ray Offset* place le GameObject à une distance définie en mètres par rapport à la surface, mais dans la direction opposée du raycast effectué.</span><span class="sxs-lookup"><span data-stu-id="96d7f-226">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="96d7f-227">Par conséquent, si le raycast est le pointage du regard de l’utilisateur, le GameObject se rapprochera le long de la ligne du point d’accès de la surface vers la caméra.</span><span class="sxs-lookup"><span data-stu-id="96d7f-227">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="96d7f-228">La propriété *Orientation Mode* détermine le type de rotation à appliquer par rapport à la normale sur la surface.</span><span class="sxs-lookup"><span data-stu-id="96d7f-228">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="96d7f-229">*None* - aucune rotation appliquée</span><span class="sxs-lookup"><span data-stu-id="96d7f-229">*None* - No rotation applied</span></span>
* <span data-ttu-id="96d7f-230">*TrackedTarget* - L’objet va faire face à la transformation suivie qui dirige le raycast</span><span class="sxs-lookup"><span data-stu-id="96d7f-230">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="96d7f-231">*SurfaceNormal* - L’objet est aligné normalement en fonction du point d’accès sur la surface</span><span class="sxs-lookup"><span data-stu-id="96d7f-231">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="96d7f-232">*Blended* - L’objet est aligné en fonction de la normale sur le point d’accès sur la surface ET en se basant sur la transformation suivie.</span><span class="sxs-lookup"><span data-stu-id="96d7f-232">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="96d7f-233">Pour forcer le GameObject associé à rester vertical dans n’importe quel mode autre que *None*, activez *Keep Orientation Vertical*.</span><span class="sxs-lookup"><span data-stu-id="96d7f-233">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="96d7f-234">Utilisez la propriété *Orientation Blend* pour contrôler l’équilibre entre les facteurs de rotation lorsque le *mode d’orientation* a la valeur *Blended*.</span><span class="sxs-lookup"><span data-stu-id="96d7f-234">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="96d7f-235">La valeur 0,0 aura une orientation entièrement pilotée par le mode *TrackedTarget* et la valeur 1,0 aura une orientation entièrement pilotée par *SurfaceNormal*.</span><span class="sxs-lookup"><span data-stu-id="96d7f-235">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![Exemple SurfaceMagnetism](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="96d7f-237">Détermination des surfaces qui peuvent être atteintes</span><span class="sxs-lookup"><span data-stu-id="96d7f-237">Determining what surfaces can be hit</span></span>

<span data-ttu-id="96d7f-238">Lorsque vous ajoutez un composant [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) à un GameObject, il est important de tenir compte de la couche du GameObject et de ses enfants, en présence de colliders.</span><span class="sxs-lookup"><span data-stu-id="96d7f-238">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="96d7f-239">Le composant fonctionne en exécutant différents types de raycasts pour déterminer la surface sur laquelle il peut agir comme un « aimant ».</span><span class="sxs-lookup"><span data-stu-id="96d7f-239">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="96d7f-240">Si le résolveur GameObject a un collider sur l’une des couches répertoriéez dans la propriété `MagneticSurfaces` de `SurfaceMagnetism`, le raycast sera probablement atteint, ce qui entraînera un attachement de GameObject à son propre point de collider.</span><span class="sxs-lookup"><span data-stu-id="96d7f-240">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="96d7f-241">Ce comportement étrange peut être évité en définissant le GameObject principal et tous les enfants sur la couche *Ignore Raycast* ou en modifiant le tableau LayerMask `MagneticSurfaces` de manière appropriée.</span><span class="sxs-lookup"><span data-stu-id="96d7f-241">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="96d7f-242">À l’inverse, un GameObject [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) n’entrera pas en conflit avec des surfaces sur une couche non répertoriée dans la propriété `MagneticSurfaces`.</span><span class="sxs-lookup"><span data-stu-id="96d7f-242">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="96d7f-243">Il est généralement recommandé de placer toutes les surfaces souhaitées sur une couche dédiée (par exemple,</span><span class="sxs-lookup"><span data-stu-id="96d7f-243">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="96d7f-244">*Surfaces*) et en définissant simplement la propriété `MagneticSurfaces` sur cette couche.</span><span class="sxs-lookup"><span data-stu-id="96d7f-244">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="96d7f-245">L’utilisation de la *default* ou de *everything* peut entraîner des composants de l’interface utilisateur ou des curseurs contribuant au résolveur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-245">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="96d7f-246">Enfin, les surfaces plus éloignées que le paramètre de propriété `MaxRaycastDistance` seront ignorées par les raycasts `SurfaceMagnetism`.</span><span class="sxs-lookup"><span data-stu-id="96d7f-246">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="directionalindicator"></a><span data-ttu-id="96d7f-247">DirectionalIndicator</span><span class="sxs-lookup"><span data-stu-id="96d7f-247">DirectionalIndicator</span></span>

<span data-ttu-id="96d7f-248">La classe [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) est un composant tag-along qui s’oriente vers la direction d’un point souhaité dans l’espace.</span><span class="sxs-lookup"><span data-stu-id="96d7f-248">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="96d7f-249">La plus couramment utilisée lorsque la propriété *Tracked Target Type* du/de la [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) est défini(e) sur [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span><span class="sxs-lookup"><span data-stu-id="96d7f-249">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="96d7f-250">De cette manière, un composant d’expérience utilisateur avec le résolveur [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) indiquera à l’utilisateur d’examiner le point souhaité dans l’espace.</span><span class="sxs-lookup"><span data-stu-id="96d7f-250">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="96d7f-251">Le point souhaité dans l’espace est déterminé par la propriété *Directional Target*.</span><span class="sxs-lookup"><span data-stu-id="96d7f-251">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="96d7f-252">Si la cible directionnelle est affichable par l’utilisateur, ou quel que soit le cadre de référence défini dans le/la [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), ce résolveur désactive tous les composants [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) qui le précèdent.</span><span class="sxs-lookup"><span data-stu-id="96d7f-252">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="96d7f-253">S’il n’est pas visible, tout sera activé sur l’indicateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-253">If not viewable, then everything will be enabled on the indicator.</span></span>

<span data-ttu-id="96d7f-254">La taille de l’indicateur diminuera à mesure que l’utilisateur est proche de capturer la *Directional Target* dans son champ de vue.</span><span class="sxs-lookup"><span data-stu-id="96d7f-254">The size of the indicator will shrink the closer the user is to capturing the *Directional Target* in their FOV.</span></span>

* <span data-ttu-id="96d7f-255">*Min Indicator Scale* - L’échelle minimale pour l’objet indicateur</span><span class="sxs-lookup"><span data-stu-id="96d7f-255">*Min Indicator Scale* - The minimum scale for the indicator object</span></span>
* <span data-ttu-id="96d7f-256">*Max Indicator Scale* - L’échelle maximale pour l’objet indicateur</span><span class="sxs-lookup"><span data-stu-id="96d7f-256">*Max Indicator Scale* - The maximum scale for the indicator object</span></span>

* <span data-ttu-id="96d7f-257">*Visibility Scale Factor* - Multiplicateur pour augmenter ou diminuer le champ de vue qui détermine si le point *Directional Target* est affichable ou non</span><span class="sxs-lookup"><span data-stu-id="96d7f-257">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="96d7f-258">*View Offset* - À partir du point de vue du cadre de référence (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="96d7f-258">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="96d7f-259">possiblement avec caméra), cette propriété définit à quel point l’objet doit être éloigné du centre de la fenêtre d’affichage.</span><span class="sxs-lookup"><span data-stu-id="96d7f-259">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="96d7f-260">![Propriétés de l’indicateur directionnel](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="96d7f-260">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="96d7f-261">*Propriétés de l’indicateur directionnel*</span><span class="sxs-lookup"><span data-stu-id="96d7f-261">*Directional Indicator properties*</span></span>

<span data-ttu-id="96d7f-262">![Exemple de scène de l’indicateur directionnel](../../images/solver/DirectionalIndicatorExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="96d7f-262">![Directional Indicator example scene](../../images/solver/DirectionalIndicatorExampleScene.gif)</span></span>  
<span data-ttu-id="96d7f-263">*Exemple de scène de l’indicateur directionnel Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="96d7f-263">*Directional Indicator Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="96d7f-264">Menu Main avec HandConstraint et HandConstraintPalmUp</span><span class="sxs-lookup"><span data-stu-id="96d7f-264">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![Exemple d’expérience utilisateur du menu Main](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="96d7f-266">Le comportement [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) fournit un résolveur qui limite l’objet suivi à une région sécurisée pour le contenu contraint à la main (par exemple, l’interface utilisateur manuelle, les menus, etc.).</span><span class="sxs-lookup"><span data-stu-id="96d7f-266">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="96d7f-267">Les régions sécurisées sont considérées comme des zones qui ne se croisent pas avec la main.</span><span class="sxs-lookup"><span data-stu-id="96d7f-267">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="96d7f-268">Une classe dérivée de [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) appelée [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) est également incluse pour illustrer un comportement courant de l’activation de l’objet suivi du résolveur lorsque la paume est orientée vers l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="96d7f-268">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="96d7f-269">Pour obtenir des exemples d’utilisation du résolveur Hand Constraint pour créer des menus manuels, [consultez la page du menu Main](../hand-menu.md).</span><span class="sxs-lookup"><span data-stu-id="96d7f-269">[Please see Hand Menu page](../hand-menu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="see-also"></a><span data-ttu-id="96d7f-270">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="96d7f-270">See also</span></span>

* [<span data-ttu-id="96d7f-271">Suivi de la main</span><span class="sxs-lookup"><span data-stu-id="96d7f-271">Hand Tracking</span></span>](../../input/hand-tracking.md)
* [<span data-ttu-id="96d7f-272">Pointage du regard</span><span class="sxs-lookup"><span data-stu-id="96d7f-272">Gaze</span></span>](../../input/gaze.md)
